# Modules and packages

## What is a package?

Writing your own modules doesn't differ much from writing ordinary scripts.

There are some specific aspects you must be aware of, but it definitely isn't rocket science. You'll see this soon enough.

![](../img/M1.3.1.png)

**Let's summarize some important issues:**
- a **module is a kind of container filled with functions** - you can pack as many functions as you want into one module and distribute it across the world;
- of course, it's generally a good idea not to mix functions with different application areas within one module (just like in a library - nobody expects scientific works to be put among comic books), so group your functions carefully and name the module containing them in a clear and intuitive way (e.g., don't give the name `arcade_games` to a module containing functions intended to partition and format hard disks)
- making many modules may cause a little mess - sooner or later you'll want to **group your modules** exactly in the same way as you've previously grouped functions - is there a more general container than a module?
- yes, there is - it's a **package**; in the world of modules, a package plays a similar role to a folder/directory in the world of files.


## Your first module: step 1

In this section you're going to be working locally on your machine. Let's start from scratch. Create an empty file, just like this:

![](../img/M1.3.2.png)


You will need two files to repeat these experiments. The first of them will be the module itself. It's empty now. Don't worry, you're going to fill it with actual code soon.

We've named the file `module.py`. Not very creative, but simple and clear.

## Your first module: step 2

The second file contains the code using the new module. Its name is `main.py`. Its content is very brief so far:

![](../img/M1.3.3.png)

> **Note:**
> **Both files have to be located in the same folder.**
> We strongly encourage you to create an empty folder for both files. Some things will be easier then.

Launch IDLE (or any other IDE you prefer) and run the `main.py` file. What do you see?

You should see nothing. This means that Python has successfully imported the contents of the `module.py` file.

It doesn't matter that the module is empty for now. The very first step has been done, but before you take the next step, we want you to take a look into the folder in which both files exist.

Do you notice something interesting?

A new subfolder has appeared - can you see it? Its name is `__pycache__`. Take a look inside. What do you see?

There is a file named (more or less) `module.cpython-xy.pyc` where `x` and `y` are digits derived from your version of Python (e.g., they will be `3` and `8` if you use `Python 3.8`).

The name of the file is the same as your module's name (module here). The part after the first dot says which Python implementation has created the file (`CPython` here) and its version number. The last part (`pyc`) comes from the words **Python** and **compiled**.

You can look inside the file - the content is completely unreadable to humans. It has to be like that, as the file is intended for Python's use only.

When Python imports a module for the first time, it **translates its contents into a somewhat compiled shape**.

The file doesn't contain machine code - it's internal Python **semi-compiled** code, ready to be executed by Python's interpreter. As such a file doesn't require lots of the checks needed for a pure source file, the execution starts faster, and runs faster, too.

Thanks to that, every subsequent import will go quicker than interpreting the source text from scratch.

Python is able to check if the module's source file has been modified (in this case, the `pyc` file will be rebuilt) or not (when the pyc file may be run at once). As this process is fully automatic and transparent, you don't have to keep it in mind.

## Your first module: step 3

Now we've put a little soemthing into the module file:

![](../img/M1.3.4.png)

Can you notice any differences between a module and an ordinary script? There are none so far.

It's possible to run this file like any other script. Try it for yourself.

What happens? You should see the following line inside your console:

```python
I like to be a module.
```

## Your first module: step 4

Let's go back to the `main.py` file:

![](../img/M1.3.5.png)

Run it. What do you see? Hopefully, you see something like this 

```
I like to be a module.
```
What does it actually mean?

When a module is imported, its content is **implicitly executed by Python**. It gives the module the chance to initialize some of its internal aspects (e.g., it may assign some variables with useful values).

Note: the **initialization takes place only once**, when the first import occurs, so the assignments done by the module aren't repeated unnecessarily.

Imagine the following context:
- there is a module named `mod1`;
- there is a module named `mod2` which contains the `import mod1` instruction;
- there is a `main` file containing the `import mod1` and `import mod2` instructions.

At first glance, you may think that `mod1` will be imported twice - fortunately, **only the first import occurs**. Python remembers the imported modules and silently omits all subsequent imports.

## Your first module: step 5
Python can do much more. It aslo creates a variable called `__name__`. 
Moreover, each source file uses its own, separate version of the variable - it isn't shared between modules. 
We'll show you how to use ut. Modify the module a bit:

> `module.py`
> ```python
>print("I like to be a module.") 
>print(__name__)
> ```

Now run the `module.py` file:
```
I like to be a module.
__main__
```
Now run the `main.py` file:
```
I like to be a module.
module
```

We can say that:

- when you run a file directly, its `__name__` variable is set to `__main__`;
- when a file is imported as a module, its `__name__` variable is set to the **file's name** (`excluding .py`)

<br><br>

## Your first module: step 6
This is how you can make use of the `__main__` variable in order to detect the context in which your code has been activated:

>module.py
>```python
>if __name__ == "__main__":
>    print("I prefer to be a module.")
>else:
>    print("I like to be a module.")
>```

There's a cleverer way to utilize the variable, however. If you write a module filled with a number of complex functions, you can use it to place a series of tests to check if the functions work properly.

Each time you modify any of these functions, you can simply run the module to make sure that your amendments didn't spoil the code. These tests will be omitted when the code is imported as a module.
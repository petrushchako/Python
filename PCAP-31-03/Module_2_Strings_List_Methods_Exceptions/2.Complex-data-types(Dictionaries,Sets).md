# Complex Data Types in Python: Working with Dictionaries & Sets in Python

## Introducing Dictionaries

- Mapping of key-value pairs
- Dictionary keys should be unique
- Keys in the same dictionary can be of different data types

```python
empty_dict = {}

bike_owners = {
    "James":"Ducati Monster 1200", 
    "Jacob":"Ducati Scrambler 1100", 
    "William":"BMW S 1000 RR", 
    "Aiden":"Harley Davidson"
    }

print(bike_owners)
print(bike_owners.keys()) # for i in bike_owners: print(i)
print(bike_owners.values())

for i in bike_owners:
    print(f" {i} : {bike_owners[i]}")

# Check if key is present in the dictionary:
print("Aiden" in bike_owners.keys()) # "Aiden" in bike_owners also returns TRUE
```

**Add and update new entry to the dictionary**
```python
bike_owners["Alex"] = "No bike"

bike_owners["Alex"] = "Lastochka"
```


**When duplicate is added, Python only uses last value with duplicated key**
```python
int_dict = {
    1 : "ONE",
    2 : "TWO",
    3 : "Three",
    3 : "THREE"
}

print(int_dict) # {1: 'ONE', 2: 'TWO', 3: 'THREE'}
```

**Accessing unavaliable key-values**
- If you know that key exists, you can use `<dict_name>[<key>]` to retriev value. However, this will throw an error if no key present:
    > Traceback (most recent call last):<br>
    >  File "c:/Users/petru/OneDrive/Desktop/GitHub/Python/test.py", line 175, in \<module\><br>
    >    print(bike_owners["Kristina"])<br>
    > KeyError: 'Kristina'

- Use `.get()` method instead. It will return **None** if key is not presnet in queried dictionary
    ```python
    print(bike_owners.get("Kristina"))
    # Output: None
    ```

**Remove key-value pairs**
```python
del bike_owners["Alex"]
```
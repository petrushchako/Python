## Is there real randomness in computers?
Another module worth mentioning is the one named **random**. 
It delivers some mechanisms allowing you to operate with pseudorandom numbers. Note the prefix pseudo - the numbers generated by the modules may look random in the sense that you cannot predict their subsequent values, but don't forget that they all are calculated using very refined algorithms.
The algorithms aren't random - they are deterministic and predictable. Only those physical processes which run completely out
of our control (like the intensity of cosmic radiation) may be used as a source of actual random data. Data produced by deterministic computers cannot be random in any way. 

A random number generator takes a value called a **seed**, treats it as an input value, calculates a **"random"**
number based on it (the method depends on a chosen algorithm) and produces a **new seed** value.

The length of a cycle in which all seed values are unique may be very long, but it isn't infinite - sooner or later the
seed values will start repeating, and the generating values will repeat, too. This is normal. It's a feature, not a
mistake, or a bug. The initial seed value, set during the program start, determines the order in which the generated values will
appear.
The random factor of the process may be augmented by setting the seed with a number taken from the current time - this may ensure that each program launch will start from a different seed value (ergo, it will use different random numbers).
Fortunately, such an initialization is done by Python during module import.

## Selected functions from the random module
### The random function
The most general function named **random()** (not to be confused with the module's name) produces a float number X coming from the **range(0.0,1.0)** in other words: **(0.0 <= x < 1.0)**.
The example program below will produce five pseudorandom values - as their values are determined by the current (rather unpredictable) seed value, you can't guess them:
```python 
from random import random
for i in range(5):
print(random())
```
#### Run the program. This is what we've got:
```
0.9535768927411208
0.5312710096244534
0.8737691983477731
0.5896799172452125
0.02116716297022092
```

### The seed function
The **seed()** function is able to directly set the  enerator's seed. We'll show you two of its variants:
* **seed()** 
<br>Sets the seed with the current time; 

* **seed(int value)**
<br>Sets the seed with the integer value int value 

We've modified the previous program - in effect, we've removed any trace of randomness from the code:
```python
from random import random, seed

seed(0)
for i in range(5) :
    print(random())
```

Due to the fact that the seed is always set with the same value, the sequence of generated values always looks the same.

Run the program. This is what we've got:
```
0.844421851525
0.75795440294
0.420571580831
0.258916750293
0.511274721369
```

Note: your values may be slightly different than ours if your system uses more precise or less precise floating-point arithmetic, but the difference will be seen quite far from the decimal point.

#### The randrange and randint functions
If you want integer random values, one of the following functions would fit better:
* **randrange(end)**
* **randrange(beg, end)**
* **randrange(beg, end, step)**
* **randint(left, right)**

The first three invocations will generate an integer taken (pseudorandomly) from
the range (respectively):
* **range(end)**
* **range(beg, end)**
* **range(beg, end, step)**

Note the implicit right-sided exclusion! The last function is an equivalent of **randrange(left, right+1)**
it generates the integer value i which falls in the range **[left, right]** (no exclusion on the right side).
Look at the code in the editor. This sample program will consequently output a
line consisting of three zeros and either a zero or one at the fourth place.

```python
from random import randrange, randint

print(randrange(1), end=' ')
print(randrange(0, 1), end=' ')
print(randrange(0, 1, 1), end=' ')
print(randint(0, 1))
```
&nbsp;<br>
The previous functions have one important disadvantage - they may produce
repeating values even if the number of subsequent invocations is not greater than the width of the specified range.
Look at the code below - the program very likely outputs a set of numbers in which some elements are not unique:
```python 
from random import randint

for i in range (10) :
    print (randint (1, 10), end=', ')
```
&nbsp;<br><br>
### The choice and sample functions
As you can see, this is not a good tool for generating numbers in a lottery.
Fortunately, there is a better solution than writing your own code to check the uniqueness of the "drawn" numbers.
It's a function named in a very suggestive way choice:
* **choice(sequence)**
* **sample(sequence, elements_to_choose)**

The first variant chooses a "random" element from the input sequence and
returns it.
The second one builds a list (a sample) consisting of the elements to choose element "drawn" from the input sequence.
In other words, the function chooses some of the input elements, returning a list with the choice. The elements in the sample are placed in random order. 
Note: 
The elements to choose must not be greater than the length of the input sequence.

Look at the code below:
```python 
from random import choice, sample

my_list = [1, 2, 3, 4, 5, 6 , 7, 8, 9, 10]
print (choice(my_list))
print (sample(my_list, 5))
print (sample(my_list, 10))
```

Again, the output of the program is not predictable. Our results looked like this:
```
 4
[3, 1, 8, 9, 101]
[10, 8, 5, 1, 6, 4, 3, 9, 7, 2]
```